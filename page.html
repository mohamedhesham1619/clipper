<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoClipper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background-color: #f8f9fa;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: white;
            border-bottom: 1px solid #eee;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #1a202c;
            margin-bottom: 2rem;
            font-size: 1.8rem;
        }

        .url-input {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .url-input input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 1rem;
        }

        .paste-btn {
            padding: 0.75rem 1rem;
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .time-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .time-input {
            width: 48%;
        }

        .time-input label {
            display: block;
            margin-bottom: 0.5rem;
            color: #4a5568;
            font-size: 0.9rem;
        }

        .time-input input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }

        .timeline {
            position: relative;
            height: 4px;
            background: #e2e8f0;
            margin: 2rem 0;
            border-radius: 2px;
        }

        .timeline-progress {
            position: absolute;
            height: 100%;
            background: #2d3748;
            border-radius: 2px;
        }

        .handle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: white;
            border: 2px solid #4a5568;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
        }

        .progress-bar {
            margin: 2rem 0;
        }

        .progress-bar-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .progress-track {
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
        }

        .progress-fill {
            width: 75%;
            height: 100%;
            background: #4a5568;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .actions {
            margin-top: 2rem;
        }

        .download-btn {
            width: 100%;
            padding: 0.75rem;
            background: #2d3748;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .duration-display {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #4a5568;
        }

        .duration-display span:first-child {
            margin-right: 0.5rem;
        }

        #durationTime {
            font-weight: bold;
        }
    </style>
</head>

<body>
    <header class="header">
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect>
                <line x1="7" y1="2" x2="7" y2="22"></line>
                <line x1="17" y1="2" x2="17" y2="22"></line>
            </svg>
            VideoClipper
        </div>
    </header>

    <main class="container">
        <h1>Create Your Video Clip</h1>

        <form id="clipForm">
            <div class="url-input">
                <input type="text" placeholder="Paste YouTube, Vimeo, or any video URL" id="videoUrl" name="videoUrl">
                <button type="button" class="paste-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M16 4h2a2 0 0 1 2 2v14a2 0 0 1-2 2H6a2 0 0 1-2-2V6a2 0 0 1 2-2h2"></path>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                </button>
            </div>

            <div class="time-controls">
                <div class="time-input">
                    <label>Start Time (hh:mm:ss)</label>
                    <input type="text" value="00:00:00" id="startTime" oninput="updateDuration()">
                </div>
                <div class="time-input">
                    <label>End Time (hh:mm:ss)</label>
                    <input type="text" value="00:02:00" id="endTime" oninput="updateDuration()">
                </div>
            </div>
            <div class="duration-display">
                <span>Duration:</span>
                <span id="durationTime">00:02:00</span>
            </div>

            <!-- <div class="timeline" id="timeline">
                <div class="timeline-progress"></div>
                <div class="handle" id="startHandle"></div>
                <div class="handle" id="endHandle"></div>
            </div> -->

            <div class="progress-bar">
                <div class="progress-bar-label">
                    <span>Processing Clip</span>
                    <span>100%</span>
                </div>
                <div class="progress-track">
                    <div class="progress-fill"></div>
                </div>
            </div>

            <div class="actions">
                <button type="submit" class="download-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Download Clip
                </button>
            </div>
        </form>
    </main>

    <script>
        // const timeline = document.getElementById('timeline');
        // const startHandle = document.getElementById('startHandle');
        // const endHandle = document.getElementById('endHandle');
        const startTimeInput = document.getElementById('startTime');
        const endTimeInput = document.getElementById('endTime');

        let isDragging = false;
        let currentHandle = null;
        const TOTAL_SECONDS = 300; // 5 minutes in seconds

        function parseTimeToSeconds(timeStr) {
            const [hours, minutes, seconds] = timeStr.split(':').map(Number);
            return hours * 3600 + minutes * 60 + seconds;
        }

        function formatTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function updateDuration() {
            const startInput = startTimeInput.value.trim();
            const endInput = endTimeInput.value.trim();

            // Only update if both inputs are in the correct format
            if (startInput.split(':').length === 3 && endInput.split(':').length === 3) {
                const startSeconds = parseTimeToSeconds(startInput);
                const endSeconds = parseTimeToSeconds(endInput);
                const durationSeconds = Math.max(0, endSeconds - startSeconds);
                document.getElementById('durationTime').textContent = formatTime(durationSeconds);
            }
        }

        // function getHandlePosition(handle) {
        //     const timelineRect = timeline.getBoundingClientRect();
        //     const handleRect = handle.getBoundingClientRect();
        //     return (handleRect.left - timelineRect.left + handleRect.width / 2) / timelineRect.width;
        // }

        // function setHandlePosition(handle, position) {
        //     position = Math.max(0, Math.min(1, position));
        //     handle.style.left = `${position * 100}%`;
        // }

        // function updateTimeFromHandle(handle, position) {
        //     const seconds = Math.floor(position * TOTAL_SECONDS);
        //     if (handle === startHandle) {
        //         startTimeInput.value = formatTime(seconds);
        //     } else {
        //         endTimeInput.value = formatTime(seconds);
        //     }
        //     updateDuration();
        // }

        // function updateHandleFromTime(timeStr, handle) {
        //     const seconds = parseTimeToSeconds(timeStr);
        //     const position = seconds / TOTAL_SECONDS;
        //     setHandlePosition(handle, position);
        //     updateTimelineProgress();
        // }

        function validateTimeInputs() {
            const startSeconds = parseTimeToSeconds(startTimeInput.value);
            const endSeconds = parseTimeToSeconds(endTimeInput.value);

            if (startSeconds > TOTAL_SECONDS) {
                startTimeInput.value = formatTime(TOTAL_SECONDS);
            }
            if (endSeconds > TOTAL_SECONDS) {
                endTimeInput.value = formatTime(TOTAL_SECONDS);
            }

            if (startSeconds > endSeconds) {
                if (currentHandle === startHandle) {
                    endTimeInput.value = startTimeInput.value;
                    updateHandleFromTime(endTimeInput.value, endHandle);
                } else {
                    startTimeInput.value = endTimeInput.value;
                    updateHandleFromTime(startTimeInput.value, startHandle);
                }
            }
            updateDuration();
        }

        // function updateHandlePosition(handle, clientX) {
        //     const timelineRect = timeline.getBoundingClientRect();
        //     let position = (clientX - timelineRect.left) / timelineRect.width;

        //     position = Math.max(0, Math.min(1, position));

        //     if (handle === startHandle) {
        //         const endPosition = getHandlePosition(endHandle);
        //         position = Math.min(position, endPosition);
        //     } else {
        //         const startPosition = getHandlePosition(startHandle);
        //         position = Math.max(position, startPosition);
        //     }

        //     setHandlePosition(handle, position);
        //     updateTimeFromHandle(handle, position);
        //     validateTimeInputs();
        //     updateTimelineProgress();
        // }

        // function updateTimelineProgress() {
        //     const startPosition = getHandlePosition(startHandle);
        //     const endPosition = getHandlePosition(endHandle);
        //     const progressBar = document.querySelector('.timeline-progress');
        //     progressBar.style.left = `${startPosition * 100}%`;
        //     progressBar.style.width = `${(endPosition - startPosition) * 100}%`;
        // }

        // [startHandle, endHandle].forEach(handle => {
        //     handle.addEventListener('mousedown', (e) => {
        //         isDragging = true;
        //         currentHandle = handle;
        //         e.preventDefault();
        //     });
        // });

        // document.addEventListener('mousemove', (e) => {
        //     if (isDragging && currentHandle) {
        //         updateHandlePosition(currentHandle, e.clientX);
        //     }
        // });

        // document.addEventListener('mouseup', () => {
        //     isDragging = false;
        //     currentHandle = null;
        // });

        function validateTimeFormat(timeStr) {
            const timeRegex = /^([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/;
            return timeRegex.test(timeStr);
        }

        [startTimeInput, endTimeInput].forEach(input => {
            input.addEventListener('keyup', (e) => {
                let value = e.target.value;

                // Auto-add colons if they're missing
                if (value.length === 2 || value.length === 5) {
                    value += ':';
                    e.target.value = value;
                }

                // Try to update duration if we have a complete time format
                if (value.split(':').length === 3) {
                    updateDuration();
                }
            });

            input.addEventListener('change', (e) => {
                let value = e.target.value;
                if (!validateTimeFormat(value)) {
                    value = '00:00:00';
                    e.target.value = value;
                }
                updateDuration();
            });

            // Also update duration when input loses focus
            input.addEventListener('blur', () => {
                updateDuration();
            });
        });

        // updateHandleFromTime(startTimeInput.value, startHandle);
        // updateHandleFromTime(endTimeInput.value, endHandle);
        // updateTimelineProgress();
        updateDuration();

        const pasteBtn = document.querySelector('.paste-btn');
        const videoUrlInput = document.getElementById('videoUrl');

        pasteBtn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                videoUrlInput.value = text;
            } catch (err) {
                console.error('Failed to read clipboard:', err);
            }
        });

        document.getElementById('clipForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const videoUrl = document.getElementById('videoUrl').value;
            const startTime = document.getElementById('startTime').value;
            const endTime = document.getElementById('endTime').value;
            const clipDuration = `${startTime}-${endTime}`;

            const socket = new WebSocket('ws://localhost:8080/submit');
            socket.onopen = () => {
                console.log('Connected to server');
                socket.send(JSON.stringify({ videoUrl, clipDuration }));
            };
            socket.onmessage = async (event) => {
                console.log('Message from server:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    if (data.status === 'done') {
                        const link = document.createElement('a');
                        link.href = data.downloadUrl;
                        link.download = ''; // Ensures the browser treats it as a download
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                } catch (error) {
                    console.error('Error:', error);
                }
            };
        });
    </script>
</body>

</html>